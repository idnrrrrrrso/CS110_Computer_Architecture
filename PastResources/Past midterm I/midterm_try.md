### ***sign-magnitude***: 

对于一个n位的有符号整数，最高位（最左边的位）被称为符号位。如果符号位为0，则整数为正数；如果符号位为1，则整数为负数。剩余的n-1位用于表示整数的幅度。

> 举个例子，假设我们有一个8位的sign-magnitude整数。如果我们有一个符号位为0，后面跟着7个位，例如1011010，那么这个整数的值将是正的，并且其幅度为01011010（即90）。
>
> 如果我们有一个符号位为1，后面跟着7个位，例如1110011，那么这个整数的值将是负的，并且其幅度为1100111（即103）。在sign-magnitude表示法中，符号位为1表示负数，幅度部分的值需要用二进制补码的方式解释。

### ***one’s complement***

- 正数的表示方式与无符号整数相同，即符号位为0，后面的n-1位用于表示数值大小。
- 负数的表示方式为其对应正数的按位取反（反码），即将符号位保持为1，而后面的n-1位为其对应正数的按位取反。

> 如果我们有一个符号位为1，后面跟着7个位，例如10100100，那么这个整数的值将是负的。我们需要将这个数的幅度部分按位取反，即01011011，这就是其对应的正数的反码。所以这个整数的值是-0110110

### ***two's complement***

- 正数的表示方式与无符号整数相同，即符号位为0，后面的n-1位用于表示数值大小。
- 负数的表示方式是其对应正数的按位取反（反码），然后加1。

 	B = 1111 1111 0010 0100 0110 0000 0000 0000

B<<5   = 1110 0100 1000 1100 0000 0000 0000 0000

XOR     = 0001 1011 1010 1000 0110 0000 0000 0000

​	     = 1	B	A	8	6	0	0	0



(2)

8+8\*9 + 1 * 81 = 161

5 + 10\*16 + 2\*16^2 = 677

677/9 = 75…2

75/9 = 8…3

8/9 …8



(3)

0 x1x0 x1x

正数

expo尽量大 = 1110 = 14，14-7 = 7

mant尽量大 = 111  = 1.111 = 1.875

send: 0111 0111 = 0x77



(b) 

expo 全0，2^{-6}

mant 尽量小 0.001 = 2^{-3}



denorm 的bias 比 norm 的小1



5. 这体有点晕晕。议题都不是很懂

(b)

t0 = 0

t1 = 0

t2 = 1

a0 = n

f_loop

t3 = t1 + t2 (新的fib数)

t1 = t2

— t2 = t3 ==addi t2, t3, 0==

a1 = t3

t0 += 1

==bneq  t0, a0, Fib_loop==





# Midterm_I

3

(b)

0111111

15 * 2^4

1 000 0001

-1 * 2^{-2}

(c)

25 = 16+8+1 = 11001

1 100 1001

4 = 100

1 101 0000



4

malloc(p*sizeof(char))





A + notB

A notB

























